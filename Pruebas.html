<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Laberinto Cubo Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #instrucciones {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instrucciones">Usa W, A, S, D o las FLECHAS para moverte</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- 1. Configuración de la Escena ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 5, 20); // Niebla para ambiente

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. Iluminación ---
        const ambientLight = new THREE.AmbientLight(0x404040); // Luz suave
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 3. Creación del Nivel (Laberinto) ---
        // 1 = Pared, 0 = Piso
        const map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        const wallGeometry = new THREE.BoxGeometry(1, 2, 1);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, side: THREE.DoubleSide });
        
        // Grupo para guardar paredes y calcular colisiones
        const walls = []; 

        // Generar el mapa
        const mapGroup = new THREE.Group();
        for (let z = 0; z < map.length; z++) {
            for (let x = 0; x < map[z].length; x++) {
                if (map[z][x] === 1) {
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x, 1, z); // Levantar pared
                    mapGroup.add(wall);
                    walls.push(wall); // Guardar referencia para colisiones
                }
            }
        }
        
        // Piso
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(4.5, 0, 4.5); // Centrar piso
        mapGroup.add(floor);
        
        scene.add(mapGroup);

        // --- 4. El Jugador (Cubo) ---
        const playerSize = 0.6;
        const playerGeometry = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
        const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x004444 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        
        // Posición inicial (asegúrate de que sea un '0' en el mapa)
        player.position.set(1, 0.3, 1); 
        scene.add(player);

        // Luz pegada al jugador
        const playerLight = new THREE.PointLight(0x00ffff, 1, 5);
        playerLight.position.set(0, 1, 0);
        player.add(playerLight);

        // --- 5. Lógica del Juego ---
        const keys = { w: false, a: false, s: false, d: false };
        const speed = 0.05;

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.key === "ArrowUp") keys.w = true;
            if (e.key === "ArrowDown") keys.s = true;
            if (e.key === "ArrowLeft") keys.a = true;
            if (e.key === "ArrowRight") keys.d = true;
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.key === "ArrowUp") keys.w = false;
            if (e.key === "ArrowDown") keys.s = false;
            if (e.key === "ArrowLeft") keys.a = false;
            if (e.key === "ArrowRight") keys.d = false;
        });

        // Función simple de colisión (Bounding Box)
        function checkCollision(newX, newZ) {
            // Creamos una caja imaginaria donde estaría el jugador
            const playerBox = new THREE.Box3();
            const tempMesh = new THREE.Mesh(playerGeometry);
            tempMesh.position.set(newX, 0.3, newZ);
            playerBox.setFromObject(tempMesh);

            // Revisamos colisión con cada pared
            for (let wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    return true; // Hay colisión
                }
            }
            return false; // Libre
        }

        // --- 6. Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            let newX = player.position.x;
            let newZ = player.position.z;

            // Movimiento (Intentamos mover en X y Z por separado para deslizarse en paredes)
            if (keys.w) newZ -= speed;
            if (keys.s) newZ += speed;
            
            // Checar colisión en Z
            if (!checkCollision(player.position.x, newZ)) {
                player.position.z = newZ;
            }

            if (keys.a) newX -= speed;
            if (keys.d) newX += speed;

            // Checar colisión en X
            if (!checkCollision(newX, player.position.z)) {
                player.position.x = newX;
            }

            // Cámara en Tercera Persona
            // Offset: atrás (z+3) y arriba (y+3)
            const cameraOffset = new THREE.Vector3(0, 3, 3); 
            const targetPosition = player.position.clone().add(cameraOffset);
            
            // Lerp para suavizar el movimiento de la cámara
            camera.position.lerp(targetPosition, 0.1);
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }

        // Ajustar si cambia el tamaño de ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>